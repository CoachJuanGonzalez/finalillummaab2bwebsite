ILLUMMAA Complete Form UX/UI Optimization - Full Implementation & Device Testing with Security
You are an expert front-end developer and UX designer. Completely redesign and optimize ALL buttons and presentation elements in the ILLUMMAA assessment form for maximum conversion, flawless performance, and enterprise-grade security across EVERY device type. Fix all mobile layout issues, ensure professional presentation, implement comprehensive security measures, and test on all possible screen sizes.
CRITICAL ISSUES TO FIX:

Mobile Layout Breaking - Buttons currently overflow on mobile screens
Form Elements Misaligned - Input fields and labels need proper spacing
Button Hierarchy Unclear - Primary vs secondary actions not visually distinct
Information Density - Too cramped on mobile, needs breathing room
Professional Polish - Needs enterprise-grade visual refinement for Build Canada Homes partnerships
Security Vulnerabilities - Missing input sanitization, XSS protection, and CSRF tokens

SECURITY IMPLEMENTATION REQUIREMENTS:
1. CONTENT SECURITY POLICY (CSP)
html<!-- Add to HTML head -->
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://www.googletagmanager.com;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
  font-src 'self' https://fonts.gstatic.com;
  img-src 'self' data: https:;
  connect-src 'self' https://services.leadconnectorhq.com https://*.replit.app;
  frame-ancestors 'none';
  base-uri 'self';
  form-action 'self';
">
2. INPUT SANITIZATION & VALIDATION
javascript// Security-focused input sanitization
class SecureFormValidator {
  constructor() {
    this.initDOMPurify();
    this.csrfToken = this.generateCSRFToken();
  }

  initDOMPurify() {
    // Initialize DOMPurify for XSS protection
    if (typeof DOMPurify === 'undefined') {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js';
      script.integrity = 'sha512-H+rglffZ6f5gF7UJgvH4Naa+fGCgjrHKMgoFOGmcPTRwR6oILo5R+gtzNrpDp7iMV3udbymBVjkeZGNz1Em4rQ==';
      script.crossOrigin = 'anonymous';
      document.head.appendChild(script);
    }
  }

  generateCSRFToken() {
    // Generate CSRF token
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }

  sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    
    // Remove any HTML tags and scripts
    let sanitized = input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
    sanitized = sanitized.replace(/<[^>]*>/g, '');
    
    // Use DOMPurify if available
    if (typeof DOMPurify !== 'undefined') {
      sanitized = DOMPurify.sanitize(sanitized, { 
        ALLOWED_TAGS: [],
        ALLOWED_ATTR: []
      });
    }
    
    // Escape special characters
    sanitized = sanitized
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
    
    return sanitized.trim();
  }

  validateEmail(email) {
    const sanitized = this.sanitizeInput(email);
    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    
    if (!emailRegex.test(sanitized)) {
      throw new Error('Invalid email format');
    }
    
    // Additional checks for suspicious patterns
    if (sanitized.includes('script') || sanitized.includes('javascript:')) {
      throw new Error('Invalid email content detected');
    }
    
    return sanitized.toLowerCase();
  }

  validatePhone(phone) {
    // Remove all non-numeric characters
    let cleaned = phone.replace(/\D/g, '');
    
    // Ensure it's a valid Canadian phone number
    if (!cleaned.startsWith('1') || cleaned.length !== 11) {
      throw new Error('Please enter a valid Canadian phone number');
    }
    
    return '+' + cleaned;
  }

  validateName(name) {
    const sanitized = this.sanitizeInput(name);
    
    // Only allow letters, spaces, hyphens, and apostrophes
    const nameRegex = /^[a-zA-Z\s'-]{2,50}$/;
    
    if (!nameRegex.test(sanitized)) {
      throw new Error('Name contains invalid characters or is too long/short');
    }
    
    return sanitized;
  }

  validateProjectUnits(units) {
    const num = parseInt(units, 10);
    
    if (isNaN(num) || num < 1 || num > 10000) {
      throw new Error('Project units must be between 1 and 10,000');
    }
    
    return num;
  }

  validateTextarea(text, maxLength = 2000) {
    const sanitized = this.sanitizeInput(text);
    
    if (sanitized.length > maxLength) {
      throw new Error(`Text exceeds maximum length of ${maxLength} characters`);
    }
    
    return sanitized;
  }
}
3. SECURE FORM SUBMISSION
javascriptclass SecureFormSubmission {
  constructor(validator) {
    this.validator = validator;
    this.rateLimiter = new RateLimiter();
  }

  async submitForm(formElement) {
    try {
      // Rate limiting check
      if (!this.rateLimiter.canSubmit()) {
        throw new Error('Too many submission attempts. Please wait before trying again.');
      }

      // Validate all form data
      const formData = this.collectAndValidateData(formElement);
      
      // Add CSRF token
      formData.csrfToken = this.validator.csrfToken;
      
      // Add timestamp for replay attack prevention
      formData.timestamp = Date.now();
      
      // Encrypt sensitive data if needed
      const encryptedData = await this.encryptSensitiveData(formData);
      
      // Submit with security headers
      const response = await this.securePost('/api/submit-lead', encryptedData);
      
      return response;
    } catch (error) {
      console.error('Secure submission failed:', error);
      throw error;
    }
  }

  collectAndValidateData(formElement) {
    const data = {};
    const formData = new FormData(formElement);
    
    // Validate each field
    for (let [key, value] of formData.entries()) {
      switch(key) {
        case 'firstName':
        case 'lastName':
          data[key] = this.validator.validateName(value);
          break;
        case 'email':
          data[key] = this.validator.validateEmail(value);
          break;
        case 'phone':
          data[key] = this.validator.validatePhone(value);
          break;
        case 'projectUnitCount':
          data[key] = this.validator.validateProjectUnits(value);
          break;
        case 'projectDescription':
          data[key] = this.validator.validateTextarea(value);
          break;
        default:
          data[key] = this.validator.sanitizeInput(value);
      }
    }
    
    return data;
  }

  async encryptSensitiveData(data) {
    // For sensitive fields, consider encryption
    const sensitiveFields = ['email', 'phone', 'firstName', 'lastName'];
    const encrypted = {...data};
    
    // In production, use proper encryption
    // This is a placeholder for demonstration
    sensitiveFields.forEach(field => {
      if (encrypted[field]) {
        // In real implementation, use Web Crypto API or similar
        encrypted[field] = btoa(encrypted[field]); // Base64 encoding (not secure, just for demo)
      }
    });
    
    return encrypted;
  }

  async securePost(url, data) {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': this.validator.csrfToken,
        'X-Requested-With': 'XMLHttpRequest'
      },
      credentials: 'same-origin',
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await response.json();
  }
}

// Rate limiting implementation
class RateLimiter {
  constructor(maxAttempts = 5, windowMs = 60000) {
    this.maxAttempts = maxAttempts;
    this.windowMs = windowMs;
    this.attempts = [];
  }

  canSubmit() {
    const now = Date.now();
    
    // Remove old attempts outside the window
    this.attempts = this.attempts.filter(timestamp => 
      now - timestamp < this.windowMs
    );
    
    // Check if under the limit
    if (this.attempts.length >= this.maxAttempts) {
      return false;
    }
    
    // Record this attempt
    this.attempts.push(now);
    return true;
  }

  getRemainingTime() {
    if (this.attempts.length === 0) return 0;
    
    const oldestAttempt = Math.min(...this.attempts);
    const timeElapsed = Date.now() - oldestAttempt;
    const timeRemaining = Math.max(0, this.windowMs - timeElapsed);
    
    return Math.ceil(timeRemaining / 1000); // Return seconds
  }
}
4. SECURE CSS IMPLEMENTATION
css/* Security-focused CSS additions */

/* Prevent clickjacking */
.assessment-form-wrapper {
  position: relative;
  z-index: 1;
}

/* Hide sensitive data from screen captures */
.sensitive-data {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Prevent form field auto-complete for sensitive fields */
.form-input[type="password"],
.form-input[autocomplete="off"] {
  -webkit-text-security: disc;
}

/* Disable text selection on buttons to prevent UI manipulation */
.btn {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
}

/* Hide error messages from screen readers initially */
.form-error:empty {
  display: none;
}

/* Secure modal overlay */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 9998;
  pointer-events: all;
}
5. COMPLETE SECURE RESPONSIVE FORM SYSTEM
javascript// Complete Secure Responsive Form System
class SecureResponsiveFormSystem {
  constructor() {
    this.currentStep = 1;
    this.totalSteps = 5;
    this.validator = new SecureFormValidator();
    this.submission = new SecureFormSubmission(this.validator);
    this.deviceType = this.detectDevice();
    this.touchDevice = 'ontouchstart' in window;
    this.sessionId = this.generateSessionId();
    this.init();
  }

  generateSessionId() {
    // Generate unique session ID for tracking
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  init() {
    this.setupSecurityHeaders();
    this.setupResponsiveListeners();
    this.optimizeForDevice();
    this.setupSecureButtonInteractions();
    this.setupSecureFormValidation();
    this.setupTouchGestures();
    this.preventCommonAttacks();
    this.testAllDevices();
  }

  setupSecurityHeaders() {
    // Add security meta tags if not present
    if (!document.querySelector('meta[http-equiv="Content-Security-Policy"]')) {
      const csp = document.createElement('meta');
      csp.httpEquiv = 'Content-Security-Policy';
      csp.content = "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;";
      document.head.appendChild(csp);
    }

    // Add X-Frame-Options
    if (!document.querySelector('meta[http-equiv="X-Frame-Options"]')) {
      const xframe = document.createElement('meta');
      xframe.httpEquiv = 'X-Frame-Options';
      xframe.content = 'DENY';
      document.head.appendChild(xframe);
    }
  }

  preventCommonAttacks() {
    // Prevent right-click on sensitive areas
    document.addEventListener('contextmenu', (e) => {
      if (e.target.closest('.form-input, .btn-submit')) {
        e.preventDefault();
        return false;
      }
    });

    // Prevent form resubmission on refresh
    if (window.history.replaceState) {
      window.history.replaceState(null, null, window.location.href);
    }

    // Detect and prevent automated form filling
    this.detectAutomation();

    // Add honeypot field for bot detection
    this.addHoneypot();
  }

  detectAutomation() {
    // Check for headless browsers and automation tools
    const isHeadless = navigator.webdriver || 
                       navigator.userAgent.includes('HeadlessChrome') ||
                       navigator.userAgent.includes('PhantomJS');
    
    if (isHeadless) {
      console.warn('Automation detected');
      // Could implement additional security measures here
    }

    // Check for unusual behavior patterns
    let mouseMovements = 0;
    document.addEventListener('mousemove', () => {
      mouseMovements++;
    });

    // Check after 2 seconds if there's human-like interaction
    setTimeout(() => {
      if (mouseMovements < 3 && this.touchDevice === false) {
        console.warn('Suspicious behavior detected');
      }
    }, 2000);
  }

  addHoneypot() {
    // Add invisible honeypot field to catch bots
    const honeypot = document.createElement('input');
    honeypot.type = 'text';
    honeypot.name = 'website'; // Bots often fill fields named "website"
    honeypot.id = 'website';
    honeypot.tabIndex = -1;
    honeypot.setAttribute('autocomplete', 'off');
    honeypot.style.cssText = 'position: absolute; left: -9999px; top: -9999px;';
    
    const form = document.querySelector('#illummaaAssessment');
    if (form) {
      form.appendChild(honeypot);
    }
  }

  setupSecureFormValidation() {
    // Add real-time validation with security checks
    document.querySelectorAll('input, select, textarea').forEach(field => {
      // Remove any existing inline event handlers
      field.removeAttribute('onchange');
      field.removeAttribute('onclick');
      field.removeAttribute('oninput');
      
      // Add secure event listeners
      field.addEventListener('blur', (e) => {
        this.secureValidateField(e.target);
      });

      field.addEventListener('input', (e) => {
        // Real-time sanitization
        if (e.target.type === 'text' || e.target.tagName === 'TEXTAREA') {
          const sanitized = this.validator.sanitizeInput(e.target.value);
          if (sanitized !== e.target.value) {
            e.target.value = sanitized;
            this.showSecurityWarning('Special characters have been removed for security');
          }
        }
      });

      // Prevent paste of malicious content
      field.addEventListener('paste', (e) => {
        e.preventDefault();
        const paste = (e.clipboardData || window.clipboardData).getData('text');
        const sanitized = this.validator.sanitizeInput(paste);
        e.target.value = sanitized;
      });
    });
  }

  secureValidateField(field) {
    try {
      let value = field.value;
      
      switch(field.name) {
        case 'firstName':
        case 'lastName':
          value = this.validator.validateName(value);
          break;
        case 'email':
          value = this.validator.validateEmail(value);
          break;
        case 'phone':
          value = this.validator.validatePhone(value);
          break;
        case 'projectUnitCount':
          value = this.validator.validateProjectUnits(value);
          break;
        case 'projectDescription':
          value = this.validator.validateTextarea(value);
          break;
        default:
          value = this.validator.sanitizeInput(value);
      }
      
      field.classList.remove('error');
      this.clearFieldError(field);
      
    } catch (error) {
      field.classList.add('error');
      this.showFieldError(field, error.message);
      return false;
    }
    
    return true;
  }

  showFieldError(field, message) {
    const errorElement = field.parentElement.querySelector('.form-error');
    if (errorElement) {
      errorElement.textContent = message;
      errorElement.setAttribute('role', 'alert');
    }
  }

  clearFieldError(field) {
    const errorElement = field.parentElement.querySelector('.form-error');
    if (errorElement) {
      errorElement.textContent = '';
      errorElement.removeAttribute('role');
    }
  }

  showSecurityWarning(message) {
    // Create temporary warning message
    const warning = document.createElement('div');
    warning.className = 'security-warning';
    warning.textContent = message;
    warning.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #FEF3C7;
      color: #92400E;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      z-index: 10000;
      animation: slideIn 0.3s ease-out;
    `;
    
    document.body.appendChild(warning);
    
    setTimeout(() => {
      warning.style.animation = 'slideOut 0.3s ease-out';
      setTimeout(() => warning.remove(), 300);
    }, 3000);
  }

  async submitForm() {
    const form = document.querySelector('#illummaaAssessment');
    const submitBtn = document.querySelector('.btn-submit');
    
    try {
      // Check honeypot
      const honeypot = document.querySelector('#website');
      if (honeypot && honeypot.value) {
        throw new Error('Bot detection triggered');
      }

      // Validate all fields
      const isValid = this.validateAllFields();
      if (!isValid) {
        throw new Error('Please complete all required fields correctly');
      }

      // Show loading state
      submitBtn.classList.add('btn-loading');
      submitBtn.disabled = true;

      // Secure submission
      const response = await this.submission.submitForm(form);
      
      // Success
      this.handleSuccessfulSubmission(response);
      
    } catch (error) {
      console.error('Submission error:', error);
      this.handleSubmissionError(error);
      
    } finally {
      submitBtn.classList.remove('btn-loading');
      submitBtn.disabled = false;
    }
  }

  validateAllFields() {
    const currentStep = document.querySelector(`.form-step[data-step="${this.currentStep}"]`);
    const fields = currentStep.querySelectorAll('input, select, textarea');
    
    let isValid = true;
    fields.forEach(field => {
      if (field.hasAttribute('required') || field.value) {
        if (!this.secureValidateField(field)) {
          isValid = false;
        }
      }
    });
    
    return isValid;
  }

  handleSuccessfulSubmission(response) {
    // Log successful submission
    console.log('Form submitted successfully', {
      sessionId: this.sessionId,
      timestamp: Date.now()
    });

    // Clear sensitive data from memory
    this.clearSensitiveData();

    // Show success message
    this.showSuccessModal(response);
  }

  handleSubmissionError(error) {
    // Log error securely
    console.error('Submission failed', {
      sessionId: this.sessionId,
      timestamp: Date.now(),
      error: error.message
    });

    // Show user-friendly error
    this.showErrorModal('We encountered an issue processing your request. Please try again.');
  }

  clearSensitiveData() {
    // Clear form data from memory
    document.querySelectorAll('input, textarea').forEach(field => {
      if (['email', 'phone', 'firstName', 'lastName'].includes(field.name)) {
        field.value = '';
      }
    });
  }

  detectDevice() {
    const width = window.innerWidth;
    if (width <= 375) return 'mobile-small';
    if (width <= 639) return 'mobile';
    if (width <= 1023) return 'tablet';
    if (width <= 1919) return 'desktop';
    return 'desktop-4k';
  }

  setupResponsiveListeners() {
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        this.deviceType = this.detectDevice();
        this.optimizeForDevice();
      }, 250);
    });
  }

  optimizeForDevice() {
    const body = document.body;
    body.className = body.className.replace(/device-\S+/g, '');
    body.classList.add(`device-${this.deviceType}`);
    
    if (this.touchDevice) {
      body.classList.add('touch-enabled');
      this.enableTouchOptimizations();
    }

    if (this.deviceType === 'mobile-small' || this.deviceType === 'mobile') {
      this.optimizeForMobile();
    } else if (this.deviceType === 'tablet') {
      this.optimizeForTablet();
    } else {
      this.optimizeForDesktop();
    }
  }

  optimizeForMobile() {
    const formNav = document.querySelector('.form-navigation');
    if (formNav) {
      formNav.style.flexDirection = 'column';
    }

    document.querySelectorAll('.btn').forEach(btn => {
      btn.style.width = '100%';
    });

    document.querySelectorAll('input, select, textarea').forEach(field => {
      field.style.fontSize = '16px';
    });
  }

  optimizeForTablet() {
    const formNav = document.querySelector('.form-navigation');
    if (formNav) {
      formNav.style.flexDirection = 'row';
    }
  }

  optimizeForDesktop() {
    const formNav = document.querySelector('.form-navigation');
    if (formNav) {
      formNav.style.flexDirection = 'row';
      formNav.style.justifyContent = 'space-between';
    }
  }

  enableTouchOptimizations() {
    document.querySelectorAll('.btn').forEach(btn => {
      btn.addEventListener('touchstart', () => {
        btn.classList.add('touch-active');
      });

      btn.addEventListener('touchend', () => {
        setTimeout(() => btn.classList.remove('touch-active'), 150);
      });
    });

    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        e.preventDefault();
      }
      lastTouchEnd = now;
    });
  }

  setupSecureButtonInteractions() {
    document.querySelectorAll('.btn').forEach(btn => {
      // Remove any inline handlers
      btn.removeAttribute('onclick');
      
      // Add secure click handler
      btn.addEventListener('click', (e) => {
        // Prevent double-click
        if (btn.dataset.clicked === 'true') {
          e.preventDefault();
          return;
        }
        
        btn.dataset.clicked = 'true';
        setTimeout(() => {
          btn.dataset.clicked = 'false';
        }, 1000);

        // Add ripple effect
        const ripple = document.createElement('span');
        ripple.classList.add('ripple');
        
        const rect = btn.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = e.clientX - rect.left - size / 2;
        const y = e.clientY - rect.top - size / 2;
        
        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = x + 'px';
        ripple.style.top = y + 'px';
        
        btn.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
      });
    });
  }

  setupTouchGestures() {
    if (!this.touchDevice) return;

    const formWrapper = document.querySelector('.assessment-form-wrapper');
    if (!formWrapper) return;

    let touchStartX = 0;
    let touchEndX = 0;

    formWrapper.addEventListener('touchstart', (e) => {
      touchStartX = e.changedTouches[0].screenX;
    });

    formWrapper.addEventListener('touchend', (e) => {
      touchEndX = e.changedTouches[0].screenX;
      const diffX = touchStartX - touchEndX;

      if (Math.abs(diffX) > 50) {
        if (diffX > 0 && this.currentStep < this.totalSteps) {
          this.nextStep();
        } else if (diffX < 0 && this.currentStep > 1) {
          this.previousStep();
        }
      }
    });
  }

  nextStep() {
    if (this.validateAllFields() && this.currentStep < this.totalSteps) {
      this.currentStep++;
      this.updateDisplay();
    }
  }

  previousStep() {
    if (this.currentStep > 1) {
      this.currentStep--;
      this.updateDisplay();
    }
  }

  updateDisplay() {
    const progressPercentage = (this.currentStep / this.totalSteps) * 100;
    const progressFill = document.querySelector('.progress-fill');
    if (progressFill) {
      progressFill.style.width = `${progressPercentage}%`;
    }

    document.querySelectorAll('.form-step').forEach(step => {
      step.classList.remove('active');
      step.style.display = 'none';
    });

    const currentStepEl = document.querySelector(`.form-step[data-step="${this.currentStep}"]`);
    if (currentStepEl) {
      currentStepEl.classList.add('active');
      currentStepEl.style.display = 'block';
    }

    const prevBtn = document.querySelector('.btn-secondary');
    const nextBtn = document.querySelector('.btn-primary:not(.btn-submit)');
    const submitBtn = document.querySelector('.btn-submit');

    if (prevBtn) {
      prevBtn.style.display = this.currentStep === 1 ? 'none' : 'flex';
    }

    if (nextBtn && submitBtn) {
      if (this.currentStep === this.totalSteps) {
        nextBtn.style.display = 'none';
        submitBtn.style.display = 'flex';
      } else {
        nextBtn.style.display = 'flex';
        submitBtn.style.display = 'none';
      }
    }

    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  showSuccessModal(response) {
    const modal = document.getElementById('successModal');
    if (modal) {
      modal.style.display = 'flex';
      // Clear any sensitive data from the modal
      const modalContent = modal.querySelector('.modal-body');
      if (modalContent) {
        modalContent.textContent = 'Your assessment has been submitted successfully. We will contact you soon.';
      }
    }
  }

  showErrorModal(message) {
    // Sanitize error message
    const sanitizedMessage = this.validator.sanitizeInput(message);
    alert(sanitizedMessage);
  }

  testAllDevices() {
    console.log('=== SECURITY & DEVICE TESTING REPORT ===');
    console.log(`Current Device: ${this.deviceType}`);
    console.log(`Screen: ${window.innerWidth}x${window.innerHeight}`);
    console.log(`Touch Enabled: ${this.touchDevice}`);
    console.log(`Session ID: ${this.sessionId}`);
    console.log(`CSRF Token: ${this.validator.csrfToken ? 'Generated' : 'Missing'}`);
    
    // Test button sizes
    document.querySelectorAll('.btn').forEach((btn, i) => {
      const rect = btn.getBoundingClientRect();
      console.log(`Button ${i+1}: ${rect.width}x${rect.height}px ${rect.width >= 44 && rect.height >= 44 ? '✅' : '⚠️'}`);
    });
    
    // Check for security headers
    console.log('CSP Header:', document.querySelector('meta[http-equiv="Content-Security-Policy"]') ? '✅' : '⚠️');
    console.log('X-Frame-Options:', document.querySelector('meta[http-equiv="X-Frame-Options"]') ? '✅' : '⚠️');
    
    // Check for honeypot
    console.log('Honeypot Field:', document.querySelector('#website') ? '✅' : '⚠️');
    
    // Check for overflow
    const hasOverflow = document.body.scrollWidth > window.innerWidth;
    console.log(`Horizontal Overflow: ${hasOverflow ? '⚠️ DETECTED' : '✅ None'}`);
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Check for HTTPS
  if (location.protocol !== 'https:' && !location.hostname.includes('localhost')) {
    console.warn('⚠️ Not running on HTTPS. Form security may be compromised.');
  }
  
  // Initialize secure form system
  const formSystem = new SecureResponsiveFormSystem();
  
  // Add global error handler for security
  window.addEventListener('error', (e) => {
    console.error('Global error caught:', e.message);
    // Could send to error tracking service
  });
  
  // Prevent form resubmission on page refresh
  if (window.history.replaceState) {
    window.history.replaceState(null, null, window.location.href);
  }
});

// Add security-focused animations
const securityStyles = document.createElement('style');
securityStyles.textContent = `
  @keyframes slideIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  
  @keyframes slideOut {
    from {
      transform: translateX(0);
      opacity: 1;
    }
    to {
      transform: translateX(100%);
      opacity: 0;
    }
  }
  
  .security-warning {
    animation: slideIn 0.3s ease-out;
  }
  
  /* Disable autocomplete on sensitive fields */
  input[autocomplete="off"],
  input[type="password"],
  input[name="email"],
  input[name="phone"] {
    autocomplete: off;
    -webkit-autocomplete: off;
  }
`;
document.head.appendChild(securityStyles);
SECURITY TESTING CHECKLIST:
INPUT VALIDATION:

 XSS prevention on all text inputs
 SQL injection prevention
 Email validation with sanitization
 Phone number format enforcement
 Name field special character filtering
 Textarea length limits enforced

CSRF & SESSION SECURITY:

 CSRF token generation and validation
 Session ID tracking
 Rate limiting on form submissions
 Honeypot field for bot detection
 Timestamp validation to prevent replay attacks

CLIENT-SIDE SECURITY:

 Content Security Policy headers
 X-Frame-Options to prevent clickjacking
 Disable autocomplete on sensitive fields
 Prevent right-click on sensitive areas
 Clear sensitive data after submission
 HTTPS enforcement check

DATA PROTECTION:

 Input sanitization with DOMPurify
 Escape special characters
 Validate data types and ranges
 Prevent paste of malicious content
 Remove inline event handlers

DEVICE & BROWSER SECURITY:

 Test on all major browsers
 Check for automation/bot detection
 Prevent double submissions
 Secure error messaging (no data leakage)
 Console logging sanitization

EXPECTED SECURITY RESULTS:
✅ XSS Protection - All user inputs sanitized
✅ CSRF Protection - Token validation on all submissions
✅ Rate Limiting - Maximum 5 submissions per minute
✅ Bot Detection - Honeypot and behavior analysis
✅ Data Validation - All fields validated before submission
✅ Secure Transmission - HTTPS enforced, sensitive data encrypted
✅ Session Security - Unique session IDs, timeout handling
✅ Error Handling - No sensitive data exposed in errors
✅ Audit Trail - All submissions logged with timestamps
✅ Compliance Ready - PIPEDA, CASL, and Build Canada Homes standards
Implement this complete secure solution to ensure enterprise-grade security alongside perfect responsive design across all devices.