ILLUMMAA Tier Calculation Fix - Complete Implementation for Replit
Instructions: Copy and paste this entire code modification into your client/src/components/assessment-form.tsx file. This fix ensures the tier calculation updates immediately when switching from "Just researching" to any planning option with units.
Find and replace your existing handleInputChange function (around lines 300-350) with this enhanced version:
typescript  // Enhanced input handler with immediate tier recalculation
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value, type } = e.target;
    const checked = (e.target as HTMLInputElement).checked;
    
    // Sanitize input value
    const rawValue = type === 'checkbox' ? checked : value;
    const sanitizedValue = type === 'checkbox' ? rawValue : sanitizeInput(value);
    
    // Special handling for readiness changes
    if (name === 'readiness') {
      const isResearching = value === 'researching';
      setIsExplorer(isResearching);
      
      if (isResearching) {
        // Explorer path: auto-set defaults
        setFormData(prev => ({
          ...prev,
          readiness: value,
          unitCount: '0',
          budget: 'Just exploring options',
          timeline: ''
        }));
        setCustomerTier('tier_0_explorer');
        setPriorityScore(0);
      } else {
        // Non-explorer path: clear fields for user selection
        setFormData(prev => ({
          ...prev,
          readiness: value,
          unitCount: '', // Clear to force selection
          budget: '',
          timeline: ''
        }));
        // Don't set tier yet - wait for unit selection
      }
    } else if (name === 'unitCount') {
      // Unit count change - always recalculate tier
      const updatedUnitCount = value;
      const currentReadiness = formData.readiness;
      
      // Security validation for commitment tiers
      if (currentReadiness && currentReadiness !== 'researching' && (value === '0' || value === '')) {
        setErrors(prev => ({ ...prev, unitCount: 'Please select actual number of units needed' }));
        return;
      }
      
      // Update form data
      setFormData(prev => ({ ...prev, unitCount: value }));
      
      // CRITICAL FIX: Immediately recalculate tier with current values
      if (currentReadiness && value) {
        const newTier = determineCustomerTier(value, currentReadiness);
        setCustomerTier(newTier);
        
        // Log for debugging (remove in production)
        console.log('Tier Calculation Debug:', {
          readiness: currentReadiness,
          unitCount: value,
          calculatedTier: newTier
        });
      }
    } else if (name === 'consentSMS' && checked) {
      // SMS consent with timestamp
      setFormData(prev => ({
        ...prev,
        consentSMS: true,
        consentSMSTimestamp: new Date().toISOString()
      }));
    } else {
      // All other fields
      setFormData(prev => ({ ...prev, [name]: sanitizedValue }));
    }
    
    // Clear field-specific errors
    setErrors(prev => ({ ...prev, [name]: '' }));
    
    // Trigger score calculation for relevant fields
    if (['unitCount', 'budget', 'timeline', 'province', 'developerType', 'governmentPrograms'].includes(name)) {
      // Use setTimeout(0) to ensure state updates are applied
      setTimeout(() => {
        calculatePriorityScore();
      }, 0);
    }
  };

  // Add this helper function if it doesn't exist
  const sanitizeInput = (value: string): string => {
    if (typeof value !== 'string') return value;
    // Enterprise-grade sanitization
    return value
      .trim()
      .replace(/[<>]/g, '') // Remove potential HTML tags
      .replace(/javascript:/gi, '') // Remove javascript: protocols
      .substring(0, 1000); // Limit length to prevent DoS
  };
Additionally, add this useEffect hook as a safety net (add after your other useEffect hooks, around line 250):
typescript  // Safety net: Ensure tier recalculation on field changes
  useEffect(() => {
    // Only recalculate if both fields have values
    if (formData.readiness && formData.unitCount !== undefined && formData.unitCount !== '') {
      const calculatedTier = determineCustomerTier(formData.unitCount, formData.readiness);
      
      // Only update if tier actually changed to prevent infinite loops
      if (calculatedTier !== customerTier) {
        setCustomerTier(calculatedTier);
        
        // Also recalculate score when tier changes
        calculatePriorityScore();
      }
    }
  }, [formData.readiness, formData.unitCount]); // Only watch these two fields
What This Fix Does:

Immediate Recalculation: When you change from "Just researching" to "Planning to buy in 12+ months" and then select "1 home", the tier immediately recalculates to "Starter Tier"
Security Maintained: All input sanitization and validation remains intact
No Race Conditions: Uses current values directly instead of waiting for state updates
Debug Logging: Includes console.log for testing (remove in production)
Safety Net: The useEffect ensures tier is always correct even if the handler misses an update

Testing After Implementation:

Select "Just researching" → Should show Explorer Tier ✓
Change to "Planning to buy in 12+ months" → Units field appears ✓
Select "1 home" → Should now show Starter Tier ✓
Change to "2 homes" → Should remain Starter Tier ✓
Go back to "1 home" → Should still show Starter Tier ✓

This implementation maintains all enterprise security practices including input sanitization, validation, and protection against XSS attacks while fixing the tier calculation bug.